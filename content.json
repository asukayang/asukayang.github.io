{"meta":{"title":"asuka-yang's blog","subtitle":"","description":"","author":"asuka yang","url":"https://asukayang.github.io","root":"/"},"pages":[],"posts":[{"title":"Python图片转字符画","slug":"Python图片转字符画","date":"2021-02-05T12:21:22.000Z","updated":"2021-02-07T06:34:02.311Z","comments":true,"path":"2021/02/05/Python图片转字符画/","link":"","permalink":"https://asukayang.github.io/2021/02/05/Python%E5%9B%BE%E7%89%87%E8%BD%AC%E5%AD%97%E7%AC%A6%E7%94%BB/","excerpt":"","text":"Python 图片转字符画是一个非常简单但实用的小程序。既可以练手熟悉Python，也可以拥有很好的Zhuang Bi效果。 既然是要将图像转成字符串，那么很明显的，必须要用到的就是Python的图像处理库，也就是大名鼎鼎的PIL，通过PIL读取图片的像素信息（灰度图是一维，如果是彩图则有RGB三个维度），再将所选择的字符串与灰度值（像素值）对应，然后输出。 图片转字符串总体来说可以有两种实现方法： 输出图片形式。创建一个空白图像，在图像上直接在像素上填上字符串。这种方式可以输出彩色图像。 输出文本形式。这种形式也就是传统的字符画。如果是灰度图，直接读取灰度值，创建字符串与灰度值的映射，写入文本并保存。如果是RGB彩图，则将彩色图转换为灰度图，在映射灰度值与字符串，写入并输出。 但要知道的是，不管用哪一种方式来进行图片的转换。都需要用PIL库对图片进行读取。 1234From PIL import Imageimg = Image.open(&quot;image.jpg&quot;) # 读取文件img_width = img.size[0] # 提取照片宽度img_height = img.size[1] # 提取照片高度 通过上面的图像完成了对图像的读取以及尺寸信息的提取。为下面的工作做准备。下面的生成字符画的部分则根据两种不同实现方法有不同的代码。 输出图片形式输出图片格式字符画的核心就是创建空白图片，映射像素值与字符串，将字符串画在之前所创建的空白图像上。这一步需要用到ImageFont和ImageDraw模块。 创建空白图片部分： 12create_array = np.ndarray([img_height,img_width,3],np.unit8)create_array[:,:,:] = 255 上面这段代码是从ndarray对象创建了一张像素值为255的空白图像。 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from PIL import Imagefrom PIL import ImageDraw,ImageFontimport numpy as npimport osdef img2char(img_path): im = Image.open(img_path) # 读取文件 img_width = im.size[0] # 提取照片宽度 img_height = im.size[1] # 提取照片高度 pix = im.load() # 提取像素值（输出pixel对象） print(&quot;The width of original Image is: %d, the height is %d&quot; % (img_width,img_height)) # 创建图像大小的三维数组 # 将数组内数值设为255 （空白图像） create_array = np.ndarray([img_height,img_width,3], np.uint8) create_array[:,:,:] = 255 # 从数组创建图片 create_img = Image.fromarray(create_array) # 创建要绘制的类和字符串 chart = list(&quot;EVA this is Asuka ! &quot;) font = ImageFont.truetype(&quot;arial.ttf&quot;, 15, encoding=&#x27;unic&#x27;) pix_count = 0 # 统计像素数量，初始值设为0 sample_step = 5 # 采样步长，因为原始图片过大，不用每个像素都采。 len_chart = len(chart) # 字符串长度 Draw = ImageDraw.Draw(create_img) # 创建图片绘制对象 for x in range(img_width): for y in range(img_height): if x % sample_step == 0 and y % sample_step == 0: # 按像素和采样率，将字符串绘制入前面所创建的空白图像 Draw.text([x,y], chart[pix_count % len_chart], pix[x,y], font) print(pix_count) pix_count +=1 # 保存图像 create_img.save(&quot;str_image.jpg&quot;) return create_imgimg2char(&quot;image.jpg&quot;) 输出结果： 可以看到，用这种方法可以话说RGB彩色字符图。根据采样步长的不同也可以调整图像的精细程度。 输出文本文件文本文件相比于上一个方法的缺点就是只能够处理灰度图 （因为最终文件的格式是.txt），所以第一步就应该是将彩色图像灰度化。RGB与灰度的转换可以使用下面的公式：$gray = 0.2126r + 0.7152g+0.0722*b$ 或者直接调用PIL库里的自动转换函数Image.convert来实现RGB与灰度的自动转换。其他部分就比较简单了，对应字符串与灰度值，写入文本，保存输出。 完整代码： 123456789101112131415161718192021222324252627282930313233343536from PIL import Imageimport numpy as np import oschar_list = &#x27;&#x27;&#x27;@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,&quot;^`&#x27;. &#x27;&#x27;&#x27;def get_char(gray_pix): length = len(char_list) # 确定字符串长度 unit = 256.0/length # 分配每个字符占据的灰度值段 return char_list[int((((length-1)*gray_pix))/256.0)] # 对应灰度值与字符img_path = &#x27;image2.jpg&#x27;img = Image.open(img_path)img_widht = img.size[0]img_height = img.size[1]# 缩放图片（因为有些图片太大所以需要缩放img = img.resize((int(img_widht*0.75),int(img_height*0.5)),Image.NEAREST) img_gray = np.array(img.convert(&#x27;L&#x27;),&#x27;f&#x27;) # 彩色图转灰度图# 创建文本文档并在相对应的位置写入对应字符text = &quot; &quot;for i in range(int(img_height*0.5)): for j in range(int(img_widht*0.75)): text = text + get_char(img_gray[i,j]) text = text + &#x27;\\n&#x27; # print(text)text_name = &quot;str_image2&quot; + &quot;.txt&quot;with open (text_name,&quot;w&quot;) as f: f.write(text) # f.close() 输出结果： 可以看到无论是那种方法输出，结果都还是不错的。","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://asukayang.github.io/tags/Python/"}]},{"title":"ImageFont库介绍","slug":"ImageFont库介绍","date":"2021-01-31T11:16:01.000Z","updated":"2021-01-31T11:39:42.517Z","comments":true,"path":"2021/01/31/ImageFont库介绍/","link":"","permalink":"https://asukayang.github.io/2021/01/31/ImageFont%E5%BA%93%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"ImageFont模块介绍ImageFont模块定义了一个同名ImageFont类。该类用于存储bitmap字体，通常和PIL.ImageDraw.ImageDraw.text()方法一起使用。 PIL使用自带的字体文件格式存储bitmap。在Windows下使用的时候可以直接调用Windows自带的字体，但要注意路径格式，否则会出现OSERROR错误。 例：(此例来自于PIL库官方文档) 12345678910111213141516from PIL import ImageFont,ImageDrawdraw = ImageDraw.Draw(image)# use bitmap fontfont = ImageFont(&#x27;arial.pil&#x27;)draw.text((10,10), &quot;hello&quot;, font=font)# use a truefont fontfont = ImageFont.truetype(&quot;arial.ttf&quot;, 15)draw.text((10,25), &quot;world&quot;, font=font) 函数 ImageFont.load(filename) 定义： 载入字体文件。该函数从已存在的bitmap文件中载入字体，并返回对应的字体对象。如果该函数运行失败，将会返回OSError错误。 变量 filename: 字体文件路径。 返回：字体对象。 错误 OSError：若文件读取错误。 ImageFont.load_path(filename) 定义：该函数作用与ImageFont.load(file)相同。 变量 filename：字体文件名 返回：字体对象。 错误 OSError： 文件读取错误。 ImageFont.truetype(font=None,size=10,index=10,encoding=&quot;,layout_engine=None 定义：从指定的文件中加载TrueType或OpenType字体文件，并根据变量创造相应的字体对象。 变量： font：一个包含了TrueTy字体的文件名或类文件对象。若文件不存在，则读取器会搜索其他的路径地址。 size：所创建字体对象的大小。 index：载入哪一种font face（默认第一个）。 encoding：选择字体编码方式（默认Unicode）。可选择的编码： “unic”（Unicode） “symb”(Microsoft Symbol) “ADOB”(Adobe Standard) “ADBE”(Adobe Expert) “ADBC”(Adobe Custom) “armn”(Apple Roman) “sjis”(Shift JIS) “gb”(PRC) “big5” “wans”(Extended Wansung) “joha”(Johab) “lat1”(Latin-1) Layout_engine：选择layout engine。可选的有：ImageFont.LAYOUT_BASIC和ImageFont.LAYOUT_RAQM。 返回：一个字体对象。 错误 OSError：文件读取错误。 ImageFont.load_default() 定义：载入”better than nothing” 默认字体 （所以这到底是个啥？？）。 此为1.1.4版本新功能。 返回： 一个字体对象。 实际例子代码： 123456789101112from Pil import Image, ImageFont, ImageDraw# open original imageim = Image.open(&quot;image.jpg&quot;)font = ImageFont.truetype(&quot;arial.ttf&quot;, 50,encoding=&#x27;unic&#x27;)draw = ImageDrwa.Draw(im)draw.text((100,150), &quot;EVA-Asuka&quot;, font=font)draw.text((100,200), &quot;hello world !!!&quot;, font=font)im.show() 原图： 添加文字后的图像：","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-01-24T13:40:02.302Z","updated":"2021-01-24T13:40:02.302Z","comments":true,"path":"2021/01/24/hello-world/","link":"","permalink":"https://asukayang.github.io/2021/01/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"第一篇博客","slug":"第一篇博客","date":"2021-01-24T08:34:58.000Z","updated":"2021-01-24T08:40:41.820Z","comments":true,"path":"2021/01/24/第一篇博客/","link":"","permalink":"https://asukayang.github.io/2021/01/24/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"一直以来都有一个写点东西的想法，但因为重度拖延症的关系，一直也没有付诸实践。这次趁着有较长的空闲时间，想了想也需要一个新的开始。 开始写博客的初衷呢，一是希望可以借由博客这个载体对自己日常所学习到的知识进行一个整理和总结。二是也算是某种意义上逼迫自己要不断地前进，不断地产出新的东西，不断地学习。希望在以后自己能不断的进步。 嘛。。。总归是希望不要鸽掉，加油吧！","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://asukayang.github.io/tags/Python/"}]}